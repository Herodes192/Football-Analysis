"""
Football API Integration Service
Handles communication with external football data API with rate limiting
"""
import httpx
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from tenacity import retry, stop_after_attempt, wait_exponential
from fastapi import HTTPException

from config.settings import get_settings
from utils.logger import setup_logger
from services.api_rate_limiter import get_rate_limiter

settings = get_settings()
logger = setup_logger(__name__)


class FootballAPIService:
    """Service for interacting with football data API with rate limiting"""
    
    def __init__(self):
        self.base_url = settings.FOOTBALL_API_BASE_URL
        self.api_key = settings.FOOTBALL_API_KEY
        self.headers = {
            "X-RapidAPI-Key": self.api_key,
            "X-RapidAPI-Host": "api-football-v1.p.rapidapi.com"
        }
        self.timeout = 30.0
        self.rate_limiter = get_rate_limiter()
    
    def _check_rate_limit(self):
        """Check if we can make an API request"""
        if not self.rate_limiter.can_make_request():
            remaining = self.rate_limiter.get_remaining_calls()
            stats = self.rate_limiter.get_usage_stats()
            logger.error(f"API rate limit exceeded. Stats: {stats}")
            raise HTTPException(
                status_code=429,
                detail=f"Daily API limit reached ({stats['calls_made']}/{stats['daily_limit']}). "
                       f"Resets tomorrow. Please use cached data."
            )
    
    @retry(stop=stop_after_attempt(2), wait=wait_exponential(multiplier=1, min=2, max=10))
    async def _make_request(self, endpoint: str, params: Dict = None) -> Dict:
        """Make HTTP request to API with retry logic and rate limiting"""
        
        # Check rate limit before making request
        self._check_rate_limit()
        
        url = f"{self.base_url}/{endpoint}"
        
        try:
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.get(url, headers=self.headers, params=params or {})
                response.raise_for_status()
                data = response.json()
                
                # Increment counter after successful request
                self.rate_limiter.increment_counter()
                
                remaining = self.rate_limiter.get_remaining_calls()
                logger.info(f"API request successful: {endpoint}. Remaining calls today: {remaining}")
                
                return data
                
        except httpx.HTTPError as e:
            logger.error(f"API request failed: {endpoint} - {str(e)}")
            raise
    
    async def get_team_fixtures(
        self, 
        team_id: int, 
        season: int = None,
        next: int = 5
    ) -> List[Dict]:
        """Get upcoming fixtures for a team (1 API call)"""
        if season is None:
            season = datetime.now().year
        
        params = {
            "team": team_id,
            "season": season,
            "next": min(next, 5)  # Limit to 5 to conserve API calls
        }
        
        data = await self._make_request("fixtures", params)
        return data.get("response", [])
    
    async def get_team_statistics(
        self, 
        team_id: int, 
        league_id: int,
        season: int = None
    ) -> Dict:
        """Get team statistics for a season (1 API call)"""
        if season is None:
            season = datetime.now().year
        
        params = {
            "team": team_id,
            "league": league_id,
            "season": season
        }
        
        data = await self._make_request("teams/statistics", params)
        return data.get("response", {})
    
    async def get_match_details(self, fixture_id: int) -> Dict:
        """Get detailed match information (1 API call)"""
        params = {"id": fixture_id}
        
        data = await self._make_request("fixtures", params)
        fixtures = data.get("response", [])
        return fixtures[0] if fixtures else {}
    
    async def get_match_statistics(self, fixture_id: int) -> List[Dict]:
        """Get match statistics (1 API call)"""
        params = {"fixture": fixture_id}
        
        data = await self._make_request("fixtures/statistics", params)
        return data.get("response", [])
    
    async def get_team_last_matches(
        self, 
        team_id: int, 
        limit: int = 5
    ) -> List[Dict]:
        """Get team's last N matches (1 API call) - Limited to 5 to conserve quota"""
        params = {
            "team": team_id,
            "last": min(limit, 5)  # Max 5 to conserve API calls
        }
        
        data = await self._make_request("fixtures", params)
        return data.get("response", [])
    
    async def get_head_to_head(
        self, 
        team1_id: int, 
        team2_id: int,
        last: int = 3
    ) -> List[Dict]:
        """Get head-to-head matches (1 API call) - Limited to 3"""
        params = {
            "h2h": f"{team1_id}-{team2_id}",
            "last": min(last, 3)  # Max 3 to conserve API calls
        }
        
        data = await self._make_request("fixtures/headtohead", params)
        return data.get("response", [])
    
    def get_api_usage_stats(self) -> dict:
        """Get current API usage statistics"""
        return self.rate_limiter.get_usage_stats()


# Singleton instance
_football_api_service = None

def get_football_api_service() -> FootballAPIService:
    """Get singleton instance of FootballAPIService"""
    global _football_api_service
    if _football_api_service is None:
        _football_api_service = FootballAPIService()
    return _football_api_service
